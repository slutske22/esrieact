"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7461],{97461:(t,e,n)=>{n.d(e,{Xl:()=>g,ct:()=>F,C$:()=>Z,PD:()=>N,VZ:()=>L,mm:()=>O,VA:()=>k,WP:()=>P,iX:()=>A,GA:()=>$,jp:()=>G,tG:()=>Q,lV:()=>C,B5:()=>E,Ye:()=>R,sg:()=>x,hM:()=>M,S2:()=>S,jD:()=>T,Zm:()=>D,$4:()=>v,bt:()=>q,rn:()=>j});var r=n(28830),a=n(30822),o=n(12690),i=n(98849),s=n(59851),u=n(76859),c=n(61985),l=n(14474);async function d(t,e,n){e=e.clone(),t.capabilities.query.supportsMaxRecordCountFactor&&(e.maxRecordCountFactor=y(t));const r=p(t),a=t.capabilities.query.supportsPagination;e.start=0,e.num=r;let o=null;for(;;){const i=await t.source.queryFeaturesJSON(e,n);if(null==o?o=i:o.features=o.features.concat(i.features),o.exceededTransferLimit=i.exceededTransferLimit,!a||!i.exceededTransferLimit)break;e.start+=r}return o}function p(t){return y(t)*function(t){return t.capabilities.query.maxRecordCount||2e3}(t)}function y(t){return t.capabilities.query.supportsMaxRecordCountFactor?l.A.MAX_MAX_RECORD_COUNT_FACTOR:1}var f=n(40454),h=n(47347),m=n(2692),w=n(27973),b=n(97724);const A=new s.J({esriGeometryPoint:"point",esriGeometryMultipoint:"multipoint",esriGeometryPolyline:"polyline",esriGeometryPolygon:"polygon",esriGeometryMultiPatch:"multipatch"});async function g(t,e,n,r){const a=await V(t);if(await I(t,e,r),!a.addAttachment)throw new i.A(r,"Layer source does not support addAttachment capability");return a.addAttachment(e,n)}function I(t,e,n){const{attributes:r}=e,{objectIdField:a}=t;return t.capabilities?.data?.supportsAttachment?e?r?a&&r[a]?Promise.resolve():Promise.reject(new i.A(n,`feature is missing the identifying attribute ${a}`)):Promise.reject(new i.A(n,"'attributes' are required on a feature to query attachments")):Promise.reject(new i.A(n,"A feature is required to add/delete/update attachments")):Promise.reject(new i.A(n,"this layer doesn't support attachments"))}async function q(t,e,n,r,a){const o=await V(t);if(await I(t,e,a),!o.updateAttachment)throw new i.A(a,"Layer source does not support updateAttachment capability");return o.updateAttachment(e,n,r)}async function F(t,e,r){const{applyEdits:a}=await n.e(5903).then(n.bind(n,75903)),o=await t.load(),{source:i,globalIdField:s}=o;let u=r;return("feature"===o.type?o.infoFor3D:null)&&null!=e.deleteFeatures&&null!=s&&(u={...u,globalIdToObjectId:await $(t,e.deleteFeatures,s)}),a(o,i,e,r)}async function j(t,e,r){const{uploadAssets:a}=await n.e(5903).then(n.bind(n,75903)),o=await t.load();return a(o,o.source,e,r)}async function O(t,e,n,r){const a=await V(t);if(await I(t,e,r),!a.deleteAttachments)throw new i.A(r,"Layer source does not support deleteAttachments capability");return a.deleteAttachments(e,n)}async function P(t,e,n){const r=(await t.load({signal:e?.signal})).source;if(!r.fetchRecomputedExtents)throw new i.A(n,"Layer source does not support fetchUpdates capability");return r.fetchRecomputedExtents(e)}async function C(t,e,n,r){e=w.A.from(e),await t.load();const a=t.source,o=t.capabilities;if(!o?.data?.supportsAttachment)throw new i.A(r,"this layer doesn't support attachments");const{attachmentTypes:s,objectIds:u,globalIds:c,num:l,size:d,start:p,where:y}=e;if(!o?.operations?.supportsQueryAttachments&&(s?.length>0||c?.length>0||d?.length>0||l||p||y))throw new i.A(r,"when 'capabilities.operations.supportsQueryAttachments' is false, only objectIds is supported",e);if(!(u?.length||c?.length||y))throw new i.A(r,"'objectIds', 'globalIds', or 'where' are required to perform attachment query",e);if(!a.queryAttachments)throw new i.A(r,"Layer source does not support queryAttachments capability",e);return a.queryAttachments(e)}async function x(t,e,n,r){const a=await V(t);if(!a.queryObjectIds)throw new i.A(r,"Layer source does not support queryObjectIds capability");return a.queryObjectIds(l.A.from(e)??t.createQuery(),n)}async function R(t,e,n,r){const a=await V(t);if(!a.queryFeatureCount)throw new i.A(r,"Layer source does not support queryFeatureCount capability");return a.queryFeatureCount(l.A.from(e)??t.createQuery(),n)}async function E(t,e,n,r){const a=await V(t);if(!a.queryExtent)throw new i.A(r,"Layer source does not support queryExtent capability");return a.queryExtent(l.A.from(e)??t.createQuery(),n)}async function M(t,e,n,r){const a=await V(t);if(!a.queryRelatedFeatures)throw new i.A(r,"Layer source does not support queryRelatedFeatures capability");return a.queryRelatedFeatures(b.default.from(e),n)}async function S(t,e,n,r){const a=await V(t);if(!a.queryRelatedFeaturesCount)throw new i.A(r,"Layer source does not support queryRelatedFeaturesCount capability");return a.queryRelatedFeaturesCount(b.default.from(e),n)}async function G(t){const e=t.source;if(e?.refresh)try{const{dataChanged:n,updates:r}=await e.refresh();if(null!=r&&(t.sourceJSON={...t.sourceJSON,...r},t.read(r,{origin:"service",url:t.parsedUrl})),n)return!0}catch{}if(t.definitionExpression)try{return(await(0,u.G)(t.definitionExpression,t.fieldsIndex)).hasDateFunctions}catch{}return!1}function L(t){const e=new l.A,n=t.capabilities?.data,r=t.capabilities?.query;e.historicMoment=t.historicMoment,e.gdbVersion=t.gdbVersion,e.returnGeometry=!0,r&&(e.compactGeometryEnabled=r.supportsCompactGeometry,e.defaultSpatialReferenceEnabled=r.supportsDefaultSpatialReference),n&&(n.supportsZ&&null!=t.returnZ&&(e.returnZ=t.returnZ),n.supportsM&&null!=t.returnM&&(e.returnM=t.returnM)),e.outFields=["*"];const{timeOffset:a,timeExtent:o}=t;return e.timeExtent=null!=a&&null!=o?o.offset(-a.value,a.unit):o||null,e.multipatchOption="multipatch"===t.geometryType?"xyFootprint":null,e}function T(t){const{globalIdField:e,fields:n}=t;if(e)return e;if(n)for(const r of n)if("esriFieldTypeGlobalID"===r.type)return r.name}function D(t){const{objectIdField:e,fields:n}=t;if(e)return e;if(n)for(const r of n)if("esriFieldTypeOID"===r.type)return r.name}function v(t){return t.currentVersion?t.currentVersion:t.hasOwnProperty("capabilities")||t.hasOwnProperty("drawingInfo")||t.hasOwnProperty("hasAttachments")||t.hasOwnProperty("htmlPopupType")||t.hasOwnProperty("relationships")||t.hasOwnProperty("timeInfo")||t.hasOwnProperty("typeIdField")||t.hasOwnProperty("types")?10:9.3}async function V(t){return(await t.load()).source}async function k(t,e,n){const a=t.parsedUrl?.path;a&&t.authenticationTriggerEvent===e&&await async function(t,e){if(!r.id)return;if(r.id.findCredential(t))return;let n;try{const a=await(0,f.wI)(t,e);a&&(n=await r.id.checkSignInStatus(`${a}/sharing`))}catch(a){}if(n)try{const n=null!=e?e.signal:null;await r.id.getCredential(t,{signal:n})}catch(a){}}(a,n)}function Z(t){return!t.sourceJSON?.isMultiServicesView&&(t.userHasUpdateItemPrivileges||t.editingEnabled)}const J=(0,c.C)({types:a.xK});function N(t,e){if(t.defaultSymbol)return t.types?.length?new m.A({defaultSymbol:J(t.defaultSymbol,t,e),field:t.typeIdField,uniqueValueInfos:t.types.map((t=>({id:t.id,symbol:J(t.symbol,t,e)})))}):new h.A({symbol:J(t.defaultSymbol,t,e)})}function Q(t){let e=t.sourceJSON?.cacheMaxAge;if(!e)return!1;const n=t.editingInfo?.lastEditDate?.getTime();return null==n||(e*=1e3,Date.now()-n<e)}async function $(t,e,n){if(null==e)return null;const r=[],{objectIdField:a}=t;if(e.forEach((t=>{let e=null;if("attributes"in t){const{attributes:r}=t;e={globalId:r[n],objectId:null!=r[a]&&-1!==r[a]?r[a]:null}}else e={globalId:t.globalId,objectId:null!=t.objectId&&-1!==t.objectId?t.objectId:null};null!=e.globalId&&(null!=e.objectId&&-1!==e.objectId||r.push(e.globalId))})),0===r.length)return null;const i=t.createQuery();i.where=r.map((t=>`${n}='${t}'`)).join(" OR "),i.returnGeometry=!1,i.outFields=[a,n],i.cacheHint=!1;const s=await(0,o.DZ)(d(t,i));if(!s.ok)return null;const u=new Map,c=s.value.features;for(const o of c){const t=o.attributes[n],e=o.attributes[a];null!=t&&null!=e&&-1!==e&&u.set(t,e)}return u}}}]);