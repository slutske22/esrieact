"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[92308],{92308:(e,t,s)=>{s.r(t),s.d(t,{SelfSnappingEngine:()=>N});var i=s(66866),r=s(52495),n=s(48982),o=s(21564),h=(s(39831),s(539),s(9272),s(63863)),a=s(17505),d=s(73569),c=s(58359),l=s(27451),p=s(97847),g=s(92976),f=s(60704),u=s(1381),x=s(61851),v=s(38175);class L{constructor(e,t){this.view=e,this.options=t,this.squaredShortLineThreshold=u.N.shortLineThreshold*u.N.shortLineThreshold}snap(e,t){return null!=t.vertexHandle?"vertex"!==t.vertexHandle.type?[]:this.snapExistingVertex(e,t):this.snapNewVertex(e,t)}edgeExceedsShortLineThreshold(e,t){return this.exceedsShortLineThreshold((0,p.Lp)(e.leftVertex.pos,this.view,t),(0,p.Lp)(e.rightVertex.pos,this.view,t),t)}exceedsShortLineThreshold(e,t,{spatialReference:s}){return 0===this.squaredShortLineThreshold||(0,x.pM)((0,v.j)(t,s,l.qt,this.view),(0,v.j)(e,s,l.qt,this.view))>this.squaredShortLineThreshold}isVertical(e,t,{spatialReference:s}){const i=(0,g.GA)(s);return(0,f.Io)((0,p.Xz)(e),(0,p.Xz)(t))*i<u.N.verticalLineThresholdMeters}squaredProximityThreshold(e){return"touch"===e?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,s=e*t;return s*s}}var E=s(59250),w=s(52857),_=s(29106),V=s(41561);class m extends L{constructor(e,t,s){super(e,t),this._geodesicLengthMeasurementUtils=s}snapNewVertex(e,t){const s=t.editGeometryOperations.data.components[0],i=s.edges.length,r=[];if(i<1)return r;const{spatialReference:n}=t,o=(0,v.j)(e,n,l.qt,this.view),{view:h}=this,a=s.edges[i-1];let d=a;do{if(this.edgeExceedsShortLineThreshold(d,t)){const s=(0,x.is)(d,h,t);this._processCandidateProposal(s.left,s.right,e,o,t,r)}d=d.leftVertex.leftEdge}while(d&&d!==a);return r}snapExistingVertex(e,t){const s=[],i=t.vertexHandle,r=i.component;if(r.edges.length<2)return s;const{view:n}=this,{spatialReference:o}=t,h=(0,v.j)(e,o,l.qt,n),a=i.leftEdge,d=i.rightEdge;a&&d&&this.edgeExceedsShortLineThreshold(a,t)&&this.edgeExceedsShortLineThreshold(d,t)&&this._processCandidateProposal((0,p.Lp)(a.leftVertex.pos,n,t),(0,p.Lp)(d.rightVertex.pos,n,t),e,h,t,s);const c=r.edges[0];let g=c;do{if(g!==i.leftEdge&&g!==i.rightEdge&&this.edgeExceedsShortLineThreshold(g,t)){const i=(0,x.is)(g,n,t);this._processCandidateProposal(i.left,i.right,e,h,t,s)}g=g.rightVertex.rightEdge}while(g&&g!==c);return s}_processCandidateProposal(e,t,s,i,r,n){const{spatialReference:o,pointer:h}=r,g=(0,c.vt)();!function(e,t,s,i,r,n){(function(e,t,s,i,{spatialReference:r},n){const o=(0,w.IP)(t,s,r,r);if(null==o)return!1;const h=(0,w.IP)(s,i,r,r);if(null==h)return!1;const c=n.geodesicDistance(s,i,r);if(null==c)return!1;const l=Math.abs(a.wf.shortestSignedDiff(o,h))>Math.PI/2?a.uC.normalize(o+Math.PI):o;return(0,w.rT)(e,s,r,(0,d.l3)(c,"meters"),(0,d.Wq)(l,"radians","geographic"),"geodesic"),e[2]=i[2],!0})(e,t,s,i,r,n)||function(e,t,s,i){(0,_.Yv)(t,{start:s,end:i,type:V.Vv.LINE},e),e[2]=t[2]}(e,i,t,s)}(g,e,t,s,r,this._geodesicLengthMeasurementUtils);const f=(0,p.de)((0,p._7)(g));(0,x.pM)(i,(0,v.j)(f,o,l.qt,this.view))<this.squaredProximityThreshold(h)&&n.push(new E.o({lineStart:e,lineEnd:t,targetPoint:f,isDraped:"on-the-ground"===r.elevationInfo?.mode}))}}var P=s(59646),T=s(84819);class y extends L{snapNewVertex(e,t){const s=t.editGeometryOperations.data.components[0],i=s.edges.length,r=s.vertices.length,n=[];if(i<2)return n;const{view:o}=this,h=(0,v.j)(e,t.spatialReference,l.qt,o),a=(0,p.Lp)(s.vertices[r-1].pos,o,t),d=(0,p.Lp)(s.vertices[0].pos,o,t),c=s.edges[i-1];let g=c;do{if(this.edgeExceedsShortLineThreshold(g,t)){const s=(0,x.is)(g,o,t);this._checkEdgeForParallelLines(s,a,e,h,t,n),this._checkEdgeForParallelLines(s,d,e,h,t,n)}g=g.leftVertex.leftEdge}while(g&&g!==c);return n}snapExistingVertex(e,t){const s=[],i=t.vertexHandle,r=i.component;if(r.edges.length<3)return s;const{view:n}=this,o=(0,v.j)(e,t.spatialReference,l.qt,n),h=i.leftEdge,a=i.rightEdge,d=r.vertices[0],c=(0,p.Lp)(d.pos,n,t),g=r.vertices.length,f=r.vertices[g-1],u=(0,p.Lp)(f.pos,n,t),L=r.edges[0];let E=L;do{if(E!==h&&E!==a&&this.edgeExceedsShortLineThreshold(E,t)){const r=(0,x.is)(E,n,t);h&&this._checkEdgeForParallelLines(r,(0,p.Lp)(h.leftVertex.pos,n,t),e,o,t,s),a&&this._checkEdgeForParallelLines(r,(0,p.Lp)(a.rightVertex.pos,n,t),e,o,t,s),i===d?this._checkEdgeForParallelLines(r,u,e,o,t,s):i===f&&this._checkEdgeForParallelLines(r,c,e,o,t,s)}E=E.rightVertex.rightEdge}while(E&&E!==L);return s}_checkEdgeForParallelLines(e,t,s,i,r,n){const o=e.left,h=e.right;if((0,V.fg)(S,(0,p.Xz)(t),(0,p.Xz)(o),(0,p.Xz)(h)),(0,f.hG)(S,(0,p.Xz)(t))<u.N.parallelLineThreshold)return;(0,V.fg)(S,(0,p.Xz)(s),(0,p.Xz)(o),(0,p.Xz)(h),(0,p.Xz)(t));const{spatialReference:a,pointer:d}=r,c=(0,p.de)((0,p.fA)(S[0],S[1],s[2]));if((0,x.pM)(i,(0,v.j)(c,a,l.qt,this.view))<this.squaredProximityThreshold(d)){if(this.isVertical(c,t,r)||this.isVertical(o,h,r))return;if(function(e,t){const s=e.left,i=e.right;for(const r of t)if((0,V.fg)(S,(0,p.Xz)(i),(0,p.Xz)(r.constraint.start),(0,p.Xz)(r.constraint.end),(0,p.Xz)(s)),(0,f.hG)(S,(0,p.Xz)(i))<u.N.parallelLineThreshold)return r.addReferenceLine(e),!0;return!1}(e,n))return;n.push(new T.B({referenceLine:e,lineStart:t,targetPoint:c,isDraped:"on-the-ground"===r.elevationInfo?.mode}))}}}const S=(0,P.vt)();var q=s(24121),z=s(81066),X=s(49935);class M extends L{constructor(e,t,s){super(e,t),this._geodesicLengthMeasurementUtils=s}snapNewVertex(e,t){const s=t.editGeometryOperations.data.components[0],i=[];if(s.vertices.length<2)return i;const{view:r}=this,n=(0,v.j)(e,t.spatialReference,l.qt,r),o=s.vertices.at(-1);this._checkForSnappingCandidate(X._b.LastVertex,i,o.leftEdge,o,o.leftEdge.leftVertex,e,n,t);const h=s.vertices[0];return this._checkForSnappingCandidate(X._b.FirstVertex,i,h.rightEdge,h,h.rightEdge.rightVertex,e,n,t),i}snapExistingVertex(e,t){const s=[],i=t.vertexHandle;if(i.component.vertices.length<3)return s;const{view:r}=this,n=(0,v.j)(e,t.spatialReference,l.qt,r),o=i.leftEdge,h=i.rightEdge;if(o?.leftVertex.leftEdge){const i=o.leftVertex.leftEdge;this._checkForSnappingCandidate(X._b.ExistingEdge,s,i,i.rightVertex,i.leftVertex,e,n,t)}if(h?.rightVertex.rightEdge){const i=h.rightVertex.rightEdge;this._checkForSnappingCandidate(X._b.ExistingEdge,s,i,i.leftVertex,i.rightVertex,e,n,t)}return s}_checkForSnappingCandidate(e,t,s,i,r,n,o,h){if(!this.edgeExceedsShortLineThreshold(s,h))return;const l=this.view,g=(0,p.Lp)(i.pos,l,h),u=(0,p.Lp)(r.pos,l,h);(function(e,t,s,i,r,n){(function(e,t,s,i,{spatialReference:r},n){const o=(0,w.IP)(t,s,r,r);if(null==o)return!1;const h=(0,w.IP)(s,i,r,r);if(null==h)return!1;const l=Math.sign(a.uC.shortestSignedDiff(o,h))*Math.PI*.5,p=(0,d.Wq)(o+l,"radians","geographic"),g=(0,c.vt)(),f=n.geodesicDistance(s,i,r);return null!=f&&((0,w.rT)(g,s,r,(0,d.l3)(f,"meters"),p,"geodesic"),(0,q.d)(e,g,s),!0)})(e,t,s,i,r,n)||function(e,t,s){const i=(0,f.Re)(C,(0,p.Xz)(s),(0,p.Xz)(t));(0,q.i)(e,i[1],-i[0],0)}(e,t,s)})(R,u,g,n,h,this._geodesicLengthMeasurementUtils),this._checkForSnappingCandidateAlongProjectedRay(e,t,u,g,R,n,o,h)}_checkForSnappingCandidateAlongProjectedRay(e,t,s,i,r,n,o,h){const{spatialReference:a,pointer:d}=h,g=(0,f.Re)(C,(0,p.Xz)(n),(0,p.Xz)(i)),u=(0,f.Om)(r,g)/(0,f.m3)(r),L=(0,f.Ln)(C,(0,p.Xz)(i),r,u),E=(0,p.de)((0,p.fA)(L[0],L[1],n[2]));if((0,x.pM)(o,(0,v.j)(E,a,l.qt,this.view))>this.squaredProximityThreshold(d)||this.isVertical(E,i,h)||this.isVertical(i,s,h))return;const w=(0,q.b)((0,c.vt)(),i,r,Math.sign(u));t.push(new X.HJ({targetPoint:E,constraint:new z.FX(i,(0,p._7)(w)),previousVertex:s,otherVertex:i,otherVertexType:X.pn.CENTER,selfSnappingType:e,isDraped:"on-the-ground"===h.elevationInfo?.mode}))}}const C=(0,P.vt)(),R=(0,c.vt)();var k=s(8947);class F extends L{snapNewVertex(e,t){const s=t.editGeometryOperations.data.components[0],i=[],r=s.vertices.length;if("polygon"!==t.editGeometryOperations.data.type||r<2)return i;const{view:n}=this,o=s.vertices[0],h=s.vertices[r-1],a=(0,p.Lp)(o.pos,n,t),d=(0,p.Lp)(h.pos,n,t);return this._processCandidateProposal(a,d,e,t,i),i}snapExistingVertex(e,t){const s=[],i=t.vertexHandle,r=i.component;if(r.edges.length<2)return s;if("polyline"===t.editGeometryOperations.data.type&&(0===i.index||i.index===r.vertices.length-1))return s;const{view:n}=this,o=(0,p.Lp)(i.leftEdge.leftVertex.pos,n,t),h=(0,p.Lp)(i.rightEdge.rightVertex.pos,n,t);return this._processCandidateProposal(o,h,e,t,s),s}_processCandidateProposal(e,t,s,i,r){if(!this.exceedsShortLineThreshold(e,t,i))return;const n=(0,f.Cc)(j,(0,p.Xz)(e),(0,p.Xz)(t),.5),o=.5*(0,f.Io)((0,p.Xz)(e),(0,p.Xz)(t)),h=(0,V.Dh)(j,(0,p.Xz)(s),n,o),a=(0,p.de)((0,p.fA)(h[0],h[1],s[2])),{spatialReference:d,pointer:c}=i,g=(0,v.j)(s,d,l.qt,this.view);if((0,x.pM)(g,(0,v.j)(a,d,l.qt,this.view))<this.squaredProximityThreshold(c)){if(this.isVertical(e,a,i)||this.isVertical(a,t,i))return;r.push(new k.R({targetPoint:a,point1:e,point2:t,isDraped:"on-the-ground"===i.elevationInfo?.mode}))}}}const j=(0,P.vt)();var I=s(40508);let N=class extends r.A{constructor(e){super(e),this.updating=!1,this._snappers=new n.A,this._domain=I.n.SELF}initialize(){this._snappers.push(new y(this.view,this.options),new m(this.view,this.options,this.geodesicLengthMeasurementUtils),new M(this.view,this.options,this.geodesicLengthMeasurementUtils),new F(this.view,this.options))}set options(e){this._set("options",e);for(const t of this._snappers)t.options=e}async fetchCandidates(e,t,s){if(!(t&this._domain&&this.options.effectiveSelfEnabled))return[];const i=[];for(const r of this._snappers.items)for(const t of r.snap(e,s))i.push(t);return(0,x.xX)(e,i),i}};(0,i._)([(0,o.MZ)({readOnly:!0})],N.prototype,"updating",void 0),(0,i._)([(0,o.MZ)({constructOnly:!0})],N.prototype,"view",void 0),(0,i._)([(0,o.MZ)({constructOnly:!0})],N.prototype,"geodesicLengthMeasurementUtils",void 0),(0,i._)([(0,o.MZ)()],N.prototype,"options",null),N=(0,i._)([(0,h.$)("esri.views.interactive.snapping.SelfSnappingEngine")],N)}}]);