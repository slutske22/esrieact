"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[66372],{22896:(e,t,n)=>{n.d(t,{a:()=>m,e:()=>p,g:()=>y,i:()=>f,l:()=>d,s:()=>l});var o=n(5262),r=n(886),s=n(65897);let c,u,i,a,l;function f(){return!!c&&(0,r.s1)()}async function d(){if(!f()){const[e]=await Promise.all([n.e(72076).then(n.bind(n,65534)),(0,r.Hh)()]);c=e.fromGeometry,u=e.fromSpatialReference,i=e.getSpatialReference,a=e.toGeometry,l=(0,r.fz)()}}function p(e,t,n={}){const{curveType:l="geodesic",unit:f}=n;f&&(t=(0,o.oU)(t,f,"meters"));const d=i(e);return a((0,r.g7)(c(e),t,u(d),s.O[l]),d)}function m(e,t,n={}){const{curveType:l="geodesic",unit:f}=n;f&&(t=(0,o.oU)(t,f,"meters"));const d=e.map(c),p=i(e);return(0,r.zo)(d,t,u(p),s.O[l]).map((e=>a(e,p)))}const y=Object.freeze(Object.defineProperty({__proto__:null,execute:p,executeMany:m,isLoaded:f,load:d,get supportsCurves(){return l}},Symbol.toStringTag,{value:"Module"}))},66372:(e,t,n)=>{n.r(t),n.d(t,{execute:()=>o.e,executeMany:()=>o.a,isLoaded:()=>o.i,load:()=>o.l,supportsCurves:()=>o.s});n(5262),n(886),n(65897);var o=n(22896)},886:(e,t,n)=>{n.d(t,{Hh:()=>u,fz:()=>l,g7:()=>i,s1:()=>c,zo:()=>a});var o=n(6530),r=n(89349);let s;function c(){return!!s&&(0,r.i)()}async function u(){if(!c()){const[e,t]=await Promise.all([Promise.all([n.e(72076),n.e(57237)]).then(n.bind(n,57237)),n.e(72076).then(n.bind(n,45262)).then((e=>e.aG)).then((({injectPe:e})=>e)),(0,r.l)()]);s=new e.OperatorGeodeticDensifyByLength,t(r.p)}}function i(e,t,n,o){return s.execute(e,t,n,o,null)}function a(e,t,n,r){const c=s.executeMany(new o.S(e),t,n,r,null);return Array.from(c)}function l(){return s.supportsCurves()}},65897:(e,t,n)=>{n.d(t,{O:()=>o});const o={geodesic:0,loxodrome:1,"great-elliptic":2,"normal-section":3,"shape-preserving":4}}}]);