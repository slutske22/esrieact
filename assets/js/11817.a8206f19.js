"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[11817],{21552:(e,t,i)=>{i.d(t,{o:()=>H});var n=i(66866),r=i(86394),s=i(98849),o=i(539),a=i(21564),l=i(73446),c=(i(39831),i(9272),i(28902)),u=i(75094),h=i(63863),m=i(97066),d=i(78983),f=i(87926),p=i(16123),y=i(76592),x=i(85470),g=i(29292),I=i(66843),R=i(64667),b=i(65228),w=i(28582),_=i(96822),S=i(75792),v=i(5572),T=i(38712),M=i(15995),k=i(80989),F=i(43124),P=i(95903),A=i(73810),D=i(54813),C=i(72717),z=i(59645),B=i(91080);const H=e=>{let t=class extends e{constructor(...e){super(...e),this._isConstructedFromFunctionRaster=!1,this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=(0,w.q)(e[0]?.raster)}destroy(){this._shutdownJobHandler()}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){"none"===e?.functionName?.toLowerCase()&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",(0,p.Jf)(e,o.A.getLogger(this)))}get renderer(){if("imagery-tile"!==this.type)return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:t}=this;if(e){const i=t?.find((({name:t})=>t===e));return i?.renderer.clone()}return this.internalRenderer}set renderer(e){"imagery-tile"===this.type&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){null==e&&null==this.rasterFunction?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,t,i){const n=t?.layerDefinition?.drawingInfo?.renderer;return(0,A.LF)(n,i)||void 0}async computeStatisticsHistograms(e,t){await this.load(t),e=(0,l.PZ)(D.A,e).clone();const{serviceRasterInfo:i}=this;if(null==i)throw new s.A("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:n}=e;if(null==n)throw new s.A("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let r=n;const{spatialReference:o}=i;if(!n.spatialReference.equals(o)){await(0,M.Hh)();const e="extent"===n.type?(0,M._l)(n,o):(0,M.uk)(n,o);if(null==e)throw new s.A("imagery-tile-mixin:compute-statistics-histograms","geometry cannot be projected to the data source");r=e}const a=e.pixelSize??new m.A({x:i.pixelSize.x,y:i.pixelSize.y,spatialReference:o}),{extent:c,width:u,height:h}=(0,v.b7)(i,r,a),d=await this.fetchPixels(c,u,h,{...t,interpolation:"nearest"});if(null==d.pixelBlock)throw new s.A("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const f=await(0,v.$Q)(d.pixelBlock,c,r),p=this._rasterJobHandler;return p?p.computeStatisticsHistograms({pixelBlock:f},t):(0,k.eH)(f)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:t}=this.serviceRasterInfo??{};if(null==t)return e;const i=(0,S.XU)({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:i,timeExtent:void 0}}async updateRasterFunction(){return this.loaded&&"imagery-tile"===this.type&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:e,symbolizer:t,renderer:i}=this;if(!e||!t||!i)return;const{rasterInfo:n}=this.raster,r=(0,S.ct)(n,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),s=r?.name,o=(0,F.m7)(n,s);return this._updateSymbolizer(t,i,s,o)}async applyRenderer(e,t,i){const n=e?.pixelBlock;if(!(null!=n&&n.pixels&&n.pixels.length>0))return null;await this.updateRenderer();const r=this.bandIds??[],{pixelBlock:s}=await this._symbolize({pixelData:e,simpleStretchParams:t,bandIds:r,symbolizer:this.symbolizer},i);return s}getTileUrl(e,t,i){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${e}/${t}/${i}`:""}getCompatibleTileInfo(e,t,i=!1){if(!this.loaded||null==t)return null;if(i&&e.equals(this.spatialReference))return this.tileInfo;const n=(0,f.Vp)(e);return b.A.create({size:256,spatialReference:e,origin:n?{x:n.origin[0],y:n.origin[1]}:{x:t.xmin,y:t.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,t,i,n={}){if(H(this),n.requestAsImageElement){const s=this.getTileUrl(e,t,i);return(0,r.A)(s,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:n.signal}).then((e=>e.data))}const{serviceRasterInfo:s}=this;if(null!=s.multidimensionalInfo&&null==(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition){const r=n.tileInfo||s.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,t,i,r),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),"raster-shaded-relief"===this.renderer?.type&&(n={...n,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,t,i,n)}async fetchPixels(e,t,i,n={}){return null!=this.serviceRasterInfo.multidimensionalInfo&&null==(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition?{extent:e,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),t=Math.round(t),i=Math.round(i),this.raster.fetchPixels(e,t,i,n))}async getSamples(e,t){if(await this.load(),(e=(0,l.PZ)(z.A,e).clone()).interpolation&&"nearest"!==e.interpolation)throw new s.A("imagery-tile-mixin:get-samples","only nearest interpolation is currently supported");const i=e.mosaicRule?.multidimensionalDefinition,n={...t,multidimensionalDefinition:i},r=(await this._getSampleLocations(e)).map((e=>this.identify(e,n).then((t=>(t.location=e,t))))),o=(await Promise.all(r)).flatMap(((e,t)=>this._convertRasterIdentifyResultToSample(e,t)));return new B.A({samples:o})}async identify(e,t={}){await this.load();const{raster:i,serviceRasterInfo:n}=this;if(null!=n?.multidimensionalInfo&&(!n.hasMultidimensionalTranspose||!(0,S.DY)(t.multidimensionalDefinition)&&!t.transposedVariableName)&&null==(t=this.normalizeRasterFetchOptions(t)).multidimensionalDefinition)return{location:e,value:null};const r=this.multidimensionalSubset?.areaOfInterest;if(r&&!r.contains(e))throw new s.A("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");const o=this.serviceRasterInfo?.storageInfo.isBsqTile&&this.bandIds?.length?this.bandIds:void 0;return i.identify(e,{...t,bandIds:o})}hasStandardTime(){const e=this.serviceRasterInfo?.multidimensionalInfo;if(null==e||"standard-time"!==this.serviceRasterInfo?.dataType)return!1;const t=this.multidimensionalDefinition,i=t?.[0]?.variableName;return e.variables.some((e=>e.name===i&&(!t?.[0].dimensionName||e.dimensions.some((e=>"StdTime"===e.name)))))}getStandardTimeValue(e){return new Date((0,S.$E)(e)).toISOString()}getMultidimensionalSubsetVariables(e){const t=e??this.serviceRasterInfo?.multidimensionalInfo;return(0,S.z2)(this.multidimensionalSubset,t)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=(0,S.fy)(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&(0,w.q)(this.raster)&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}async _initJobHandler(){if(!this._rasterJobHandler)return super._initJobHandler().then((async()=>{if(!this._rasterJobHandler)return;H(this);const{raster:e}=this;e.rasterJobHandler=this._rasterJobHandler,(0,w.q)(e)&&e.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch((()=>{})),this.renderer&&this.updateRenderer()})).catch((()=>{}))}_shutdownJobHandler(){super._shutdownJobHandler(),this.raster&&(this.raster.rasterJobHandler=null)}async _getSampleLocations(e){const{geometry:t}=e;if("point"===t.type)return[t];const{spatialReference:n,type:r}=t;if("multipoint"===r)return t.points.map((e=>new m.A({x:e[0],y:e[1],spatialReference:n})));if("polyline"===r){let r=t;if(e.sampleCount||e.sampleDistance){const n=await Promise.all([i.e(72076),i.e(89468)]).then(i.bind(i,89468)),s=(await Promise.all([i.e(72076),i.e(81468)]).then(i.bind(i,81468))).execute(t,{unit:"meters"}),o=Math.min(e.sampleCount||100,1e3);let a=e.sampleDistance;a||(a=s/(o+(2===r.paths[0].length?1:0))),r=n.execute(t,a,{unit:"meters"})}return r.paths.flatMap((e=>e.map((e=>new m.A({x:e[0],y:e[1],spatialReference:n})))))}const s=Math.min(e.sampleCount||100,1e3),o="extent"===t.type,a=o?t:t.extent,l=Math.sqrt(a.width*a.height/s),c=a.height/l,u=a.width/l,{xmin:h,ymax:d}=a,f=[];for(let i=0;i<c;i++)for(let e=0;e<u;e++){const r=new m.A({x:h+(e+.5)*l,y:d-(i+.5)*l,spatialReference:n});(o||t.contains(r))&&f.push(r)}return f}_configDefaultInterpolation(){if(null==this.interpolation){H(this);const{raster:e}=this,t=(0,F.w6)(e.rasterInfo,e.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",t)}}_configDefaultRenderer(e="no"){H(this);const{rasterInfo:t}=this.raster,i=(0,S.ct)(t,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),n=i?.name,r=(0,F.I8)({variableName:n,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&t.bandCount>1&&(this.bandIds=r?.bandIds??(0,F.ci)(t)),!this.renderer||"override"===e){const e=(0,F.Mm)(this.raster),i=r?.renderer??(0,F.PD)(t,{bandIds:this.bandIds,variableName:n,rasterFunctionColorRamp:e}),s=t.statistics,o=s&&s.length>0?s[0]:null,a=o?.max??0,l=o?.min??0;"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===i.type&&(a>1e24||l<-1e24)&&(i.dynamicRangeAdjustment=!0,i.customStatistics=null,"none"===i.stretchType&&(i.stretchType="min-max")),this.renderer=i}const s=(0,F.$P)({...this.renderer.toJSON(),variableName:n}),a=(0,F.m7)(t,n);this.symbolizer?(this.symbolizer.rendererJSON=s,this.symbolizer.rasterInfo=a):this.symbolizer=new P.A({rendererJSON:s,rasterInfo:a});const l=this.symbolizer.bind();if(l.success){if("auto"===e){const{colormap:e}=this.raster.rasterInfo,t=this.renderer;if(null!=e&&"raster-colormap"===t.type){const e=(0,F.PD)(this.raster.rasterInfo);JSON.stringify(e)!==JSON.stringify(t)&&this._configDefaultRenderer("override")}else if("raster-stretch"===t.type){const e=this.bandIds?.length,i=t.customStatistics?.length;!t.dynamicRangeAdjustment&&i&&e&&i!==e&&this._configDefaultRenderer("override")}}}else o.A.getLogger(this).warn("imagery-tile-mixin",l.error||"The given renderer is not supported by the layer."),"auto"===e&&this._configDefaultRenderer("override")}async _updateRasterFunction(){if(this._isConstructedFromFunctionRaster&&(0,w.q)(this.raster)){const e=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&e&&this._set("rasterFunction",R.A.fromJSON(e)))}let e,t=this.raster,i=!1;(0,w.q)(t)?(e=t.primaryRasters.rasters,t=e[0],i=!0):e=[t];const{rasterFunction:n}=this;if(n){const i={raster:t};e.length>1&&e.forEach((e=>i[e.url]=e));const r=(0,T.vt)(n.functionDefinition?.toJSON()??n.toJSON(),i),s=new _.A({rasterFunction:r});s.rasterJobHandler=this._rasterJobHandler,await s.open(),this.raster=s}else this.raster=t,await t.open();if(this._cachedRendererJson=void 0,!i&&!n)return;const{bandIds:r}=this,{bandCount:s}=this.raster.rasterInfo,o=r?.length?r.some((e=>e>=s)):s>=3;r&&(o||this.renderer&&"raster-stretch"!==this.renderer.type)&&this._set("bandIds",null),this._configDefaultRenderer("auto")}_convertRasterIdentifyResultToSample(e,t){const{rasterInfo:i}=this.raster,n=i.storageInfo.pyramidScalingFactor**(e.pyramidLevel??0),r=(i.pixelSize.x+i.pixelSize.y)/2*n;if(!e.dataSeries?.length)return[new C.A({location:e.location,pixelValue:e.value,locationId:t,resolution:r})];const s=[];return e.dataSeries.forEach((({value:i,multidimensionalDefinition:n},o)=>{const a={Variables:n[0].variableName,Dimensions:n.flatMap((({dimensionName:e})=>e)).join(",")};for(const{dimensionName:e,values:t}of n){a[e]=Array.isArray(t[0])?t[0][0]:t[0];const i=t[t.length-1];a[`${e}_Max`]=Array.isArray(i)?i[i.length-1]:i}const l=new C.A({location:e.location,pixelValue:i,rasterId:o,locationId:t,resolution:r,attributes:a});s.push(l)})),s}};function H(e){if(!e.raster||!e.serviceRasterInfo)throw new s.A("imagery-tile","no raster")}return(0,n._)([(0,a.MZ)({clonable:!1})],t.prototype,"_cachedRasterFunctionJson",void 0),(0,n._)([(0,a.MZ)({clonable:!1})],t.prototype,"_compatibleFullExtent",void 0),(0,n._)([(0,a.MZ)({clonable:!1})],t.prototype,"_isConstructedFromFunctionRaster",void 0),(0,n._)([(0,a.MZ)({clonable:!1})],t.prototype,"_rasterFunctionUpdatePromise",void 0),(0,n._)([(0,a.MZ)({type:[l.jz],json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"0,1,2"!==this.bandIds?.join(",")}}}}})],t.prototype,"bandIds",void 0),(0,n._)([(0,a.MZ)({json:{origins:{service:{read:{source:"copyrightText"}}}}})],t.prototype,"copyright",void 0),(0,n._)([(0,a.MZ)({json:{read:!1}})],t.prototype,"fullExtent",null),(0,n._)([(0,a.MZ)({json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"bilinear"!==this.interpolation}}}}}),(0,c.e)(I.SZ)],t.prototype,"interpolation",void 0),(0,n._)([(0,a.MZ)()],t.prototype,"ioConfig",void 0),(0,n._)([(0,a.MZ)({type:[x.A],json:{write:!0}})],t.prototype,"multidimensionalDefinition",null),(0,n._)([(0,a.MZ)({type:g.A,json:{write:!0}})],t.prototype,"multidimensionalSubset",void 0),(0,n._)([(0,a.MZ)()],t.prototype,"raster",void 0),(0,n._)([(0,a.MZ)({type:R.A})],t.prototype,"rasterFunction",null),(0,n._)([(0,a.MZ)()],t.prototype,"serviceRasterInfo",void 0),(0,n._)([(0,a.MZ)()],t.prototype,"sourceJSON",void 0),(0,n._)([(0,a.MZ)({readOnly:!0,type:d.A,json:{read:!1}})],t.prototype,"spatialReference",void 0),(0,n._)([(0,a.MZ)({type:b.A})],t.prototype,"tileInfo",void 0),(0,n._)([(0,a.MZ)(y.OZ)],t.prototype,"url",null),(0,n._)([(0,a.MZ)()],t.prototype,"renderer",null),(0,n._)([(0,a.MZ)({types:A.uy,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const e="raster-stretch"===this.renderer?.type&&"none"===this.renderer.stretchType&&!this.renderer.useGamma;return{enabled:!this.loaded||"Raster"===this.raster.tileType||!e}}},origins:{"web-scene":{types:A.Gj,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&"vector-field"!==e.type&&"flow"!==e.type})}}}}})],t.prototype,"internalRenderer",null),(0,n._)([(0,u.w)("internalRenderer")],t.prototype,"readRenderer",null),(0,n._)([(0,a.MZ)({clonable:!1})],t.prototype,"symbolizer",void 0),t=(0,n._)([(0,h.$)("esri.layers.mixins.ImageryTileMixin")],t),t}},55799:(e,t,i)=>{i.d(t,{A:()=>A});var n=i(66866),r=i(86394),s=i(98849),o=i(21877),a=i(539),l=i(40189),c=i(92746),u=i(21564),h=i(73446),m=(i(39831),i(9272),i(63863)),d=i(84698),f=i(97066),p=i(78983),y=i(16123),x=i(76592),g=i(85470),I=i(50437),R=i(19044),b=i(65228),w=i(28582),_=i(75792),S=i(75786),v=i(22036),T=i(32876),M=i(20498),k=i(15995),F=i(56889);let P=0,A=class extends o.A{constructor(){super(...arguments),this._tileFetchQueue=new c.QueueProcessor({concurrency:32,process:(e,t)=>this._fetchRawTile(e.pyramidLevel,e.row,e.col,{...e.options,signal:t})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(e){return e?.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:b.A.create(),...e.ioConfig}}),e}get _isGlobalWrappableSource(){const{rasterInfo:e}=this,t=(0,k.FT)(e.spatialReference);return null!=t&&e.extent.width>=t/2}get _hasNoneOrGCSShiftTransform(){const{transform:e}=this.rasterInfo;return null==e||"gcs-shift"===e.type}set rasterJobHandler(e){this._set("rasterJobHandler",e),(0,w.q)(this)&&this.primaryRasters?.rasters?.forEach((t=>t.rasterJobHandler=e))}get rasterId(){return this.url||"rasterId-"+P++}set url(e){this._set("url",(0,y.Jf)(e,a.A.getLogger(this)))}async open(e){return this._openPromise??=(0,k.Hh)().then((()=>this._open(e))),this._openPromise}async fetchTile(e,t,i,n={}){const r=n.tileInfo||this.rasterInfo.storageInfo.tileInfo,s=this.getTileExtentFromTileInfo(e,t,i,r);return n={noClip:!0,...n},this.fetchPixels(s,r.size[0],r.size[1],n)}async identify(e,t={}){e=(0,h.PZ)(f.A,e).clone().normalize();const{multidimensionalDefinition:i,timeExtent:n}=t,{rasterInfo:r}=this,{hasMultidimensionalTranspose:s,multidimensionalInfo:o}=r;let{transposedVariableName:a}=t;const l=null!=o&&s&&(null!=n||(0,_.DY)(i));l&&!a&&(a=null!=i&&i.length>0?i[0].variableName??void 0:o.variables[0].name,t={...t,transposedVariableName:a}),t=this._getRequestOptionsWithSliceId(t);const{spatialReference:c,extent:u}=r,{datumTransformation:m}=t;let p=(0,k._I)(e,c,m);if(!u.intersects(p))return{location:p,value:null};if(null!=r.transform){const e=r.transform.inverseTransform(p);if(!r.nativeExtent.intersects(e))return{location:e,value:null};p=e}let y=0;const x=null!=a&&null!=o&&r.hasMultidimensionalTranspose;if((0,w.q)(this)){const e=this.primaryRasters.rasters[0];if(x)return e.identify(p,t);const{pixelSize:n}=r,s=3,o=n.x*s/2,a=n.y*s/2,l=new d.A({xmin:p.x-o,xmax:p.x+o,ymin:p.y-a,ymax:p.y+a,spatialReference:c}),u={interpolation:"nearest",multidimensionalDefinition:i,sliceId:t.sliceId},{pixelBlock:h}=await e.fetchPixels(l,s,s,u),{pixelBlock:m}=await this.fetchPixels(l,s,s,u);if(null==h)return{location:p,value:null};const f=Math.floor(s*s*.5),y=!h.mask||h.mask[f]?h.pixels.map((e=>e[f])):null;let g;return null!=m&&(g=!m.mask||m.mask[f]?m.pixels.map((e=>e[f])):void 0),{location:p,value:y,processedValue:g,pyramidLevel:0}}if(!x)if(t.srcResolution)y=(0,k.t$)(t.srcResolution,r,this.ioConfig.sampling).pyramidLevel;else if(y=await this.computeBestPyramidLevelForLocation(e,t),null==y)return{location:p,value:null};const g=this.identifyPixelLocation(p,y,null,x);if(null===g)return{location:p,value:null};const{row:I,col:R,rowOffset:b,colOffset:S,blockWidth:v}=g,T=await this._tileFetchQueue.push({pyramidLevel:y,row:I,col:R,options:t},{signal:t.signal});if(!T?.pixels?.length)return{location:p,value:null};const M=b*v+S;return this._processIdentifyResult(T,{srcLocation:p,position:M,pyramidLevel:y,useTransposedTile:!!x,requestSomeSlices:l,identifyOptions:t})}async fetchPixels(e,t,i,n={}){e=(0,k.Ps)(e),n=this._getRequestOptionsWithSliceId(n);const{_hasNoneOrGCSShiftTransform:r}=this;if(n.requestRawData&&r)return this._fetchPixels(e,t,i,n);const s=(0,k.FT)(e.spatialReference),o=(0,k.OM)(e);if(null==s||0===o||1===o&&this._isGlobalWrappableSource&&r)return this._fetchPixels(e,t,i,n);if(o>=3)return{extent:e,pixelBlock:null};const a=[],{xmin:l,xmax:c}=e,u=Math.round(s/(c-l)*t),h=u-Math.round((s/2-l)/(c-l)*t);let m=0;const f=[];for(let g=0;g<=o;g++){const r=new d.A({xmin:0===g?l:-s/2,xmax:g===o?c-s*g:s/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),p=0===g?u-h:g===o?t-m:u;m+=p,f.push(p);const y=n.disableWrapAround&&g>0?null:this._fetchPixels(r,p,i,n);a.push(y)}const p=(await Promise.all(a)).map((e=>e?.pixelBlock));let y=null;const x={width:t,height:i};return y=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:x,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:f},n)).pixelBlock:(0,M.z7)(p,x,{blockWidths:f}),{extent:e,srcExtent:(0,k._l)(e,this.rasterInfo.spatialReference,n.datumTransformation),pixelBlock:y}}async fetchRawPixels(e,t,i,n={}){t={x:Math.floor(t.x),y:Math.floor(t.y)};const r=await this._fetchRawTiles(e,t,i,n),{nativeExtent:s,nativePixelSize:o,storageInfo:a}=this.rasterInfo,l=2**e,c=o.x*l,u=o.y*l,h=new d.A({xmin:s.xmin+c*t.x,xmax:s.xmin+c*(t.x+i.width-1),ymin:s.ymax-u*(t.y+i.height-1),ymax:s.ymax-u*t.y,spatialReference:s.spatialReference});if(!r)return{extent:h,srcExtent:h,pixelBlock:null};const{pixelBlocks:m,mosaicSize:f}=r;if(1===m.length&&null!=m[0]&&m[0].width===i.width&&m[0].height===i.height)return{extent:h,srcExtent:h,pixelBlock:r.pixelBlocks[0]};const p=e>0?a.pyramidBlockWidth:a.blockWidth,y=e>0?a.pyramidBlockHeight:a.blockHeight,x={x:t.x%p,y:t.y%y};let g;return g=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:m,srcMosaicSize:f,destDimension:i,clipOffset:x,clipSize:i,coefs:null,sampleSpacing:null,interpolation:n.interpolation,alignmentInfo:null,blockWidths:null},n)).pixelBlock:(0,M.z7)(m,f,{clipOffset:x,clipSize:i}),{extent:h,srcExtent:h,pixelBlock:g}}fetchRawTile(e,t,i,n){throw new s.A("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return(0,k._l)(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?(0,T.D)(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,t,i=0){const{customFetchParameters:n}=this.ioConfig,{range:s,query:o,headers:a}=t;i=i??t.retryCount??this.ioConfig.retryCount;const l=s?{Range:`bytes=${s.from}-${s.to}`}:null;try{return await(0,r.A)(e,{...t,query:{...o,...n},headers:{...a,...l}})}catch(c){if(i>0)return i--,this.request(e,t,i);throw c}}getSliceIndex(e){const{multidimensionalInfo:t}=this.rasterInfo;return null==t||null==e||0===e.length?null:(0,_.NG)(e,t)}getTileExtentFromTileInfo(e,t,i,n){const r=n.lodAt(e);return this.getTileExtent({x:r.resolution,y:r.resolution},t,i,n.origin,n.spatialReference,n.size)}updateTileInfo(){const{storageInfo:e,spatialReference:t,extent:i,pixelSize:n}=this.rasterInfo,{pyramidResolutions:r}=e;if(!e.tileInfo){const s=[],o=e.maximumPyramidLevel||0;let a=(n.x+n.y)/2,l=1/.0254*96*a;for(let e=0;e<=o&&(s.unshift(new I.A({level:o-e,resolution:a,scale:l})),e!==o);e++)if(r){const t=(r[e].x+r[e].y)/2;l*=t/a,a=t}else a*=2,l*=2;const c=new f.A({x:i.xmin,y:i.ymax,spatialReference:t});e.tileInfo=new b.A({origin:c,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:s}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,t=512,i=512,n){const{width:r,height:s,nativeExtent:o,pixelSize:a,spatialReference:l}=e,c=new f.A({x:o.xmin,y:o.ymax,spatialReference:l});null==n&&(n=Math.max(0,Math.round(Math.log(Math.max(r,s))/Math.LN2-8)));const u=this.computeBlockBoundary(o,512,512,{x:o.xmin,y:o.ymax},[a],n);e.storageInfo=new R.A({blockWidth:t,blockHeight:i,pyramidBlockWidth:t,pyramidBlockHeight:i,origin:c,firstPyramidLevel:1,maximumPyramidLevel:n,blockBoundary:u})}async computeBestPyramidLevelForLocation(e,t={}){return 0}computeBlockBoundary(e,t,i,n,r,s=0,o=2){if(1===r.length&&s>0){r=[...r];let{x:e,y:t}=r[0];for(let i=0;i<s;i++)e*=o,t*=o,r.push({x:e,y:t})}const a=[],{x:l,y:c}=n;for(let u=0;u<r.length;u++){const{x:n,y:s}=r[u];a.push({minCol:Math.floor((e.xmin-l+.1*n)/t/n),maxCol:Math.floor((e.xmax-l-.1*n)/t/n),minRow:Math.floor((c-e.ymax+.1*s)/i/s),maxRow:Math.floor((c-e.ymin-.1*s)/i/s)})}return a}getPyramidPixelSize(e){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:i,pyramidScalingFactor:n}=this.rasterInfo.storageInfo;if(0===e)return t;if(null!=i&&i.length)return i[e-1];const r=n**e;return{x:t.x*r,y:t.y*r}}identifyPixelLocation(e,t,i,n){const{spatialReference:r,nativeExtent:s,storageInfo:o}=this.rasterInfo,{maximumPyramidLevel:a,origin:l,transposeInfo:c}=o,u=n&&null!=c?c.tileSize[0]:o.blockWidth,h=n&&null!=c?c.tileSize[1]:o.blockHeight,m=(0,k._I)(e,r,i);if(!s.intersects(m))return null;if(t<0||t>a)return null;const d=this.getPyramidPixelSize(t),{x:f,y:p}=d,y=(l.y-m.y)/p/h,x=(m.x-l.x)/f/u,g=Math.min(h-1,Math.floor((y-Math.floor(y))*h)),I=Math.min(u-1,Math.floor((x-Math.floor(x))*u));return{pyramidLevel:t,row:Math.floor(y),col:Math.floor(x),rowOffset:g,colOffset:I,blockWidth:u,srcLocation:m}}getTileExtent(e,t,i,n,r,s){const[o,a]=s,l=n.x+i*o*e.x,c=l+o*e.x,u=n.y-t*a*e.y,h=u-a*e.y;return new d.A({xmin:l,xmax:c,ymin:h,ymax:u,spatialReference:r})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,i){const n=this.rasterInfo.storageInfo.blockBoundary[e];return!n||n.maxRow<t||n.maxCol<i||n.minRow>t||n.minCol>i}updateImageSpaceRasterInfo(e){const{pixelSize:t}=e,{width:i,height:n}=e,r=p.A.WebMercator;e.spatialReference=r,e.extent=e.nativeExtent=new d.A({xmin:-.5,ymax:.5,xmax:i-.5,ymin:.5-n,spatialReference:r}),e.isPseudoSpatialReference=!0,e.transform=null,e.pixelSize=new f.A({x:1,y:1,spatialReference:r});const{extent:s,storageInfo:o}=e;if(o){o.origin=new f.A({x:s.xmin,y:s.ymax,spatialReference:r});const{pyramidResolutions:i,tileInfo:n}=o;if(i&&i.forEach((e=>{e.x/=t.x,e.y/=t.y})),n){n.origin=o.origin;const t=(e.nativePixelSize.x+e.nativePixelSize.y)/2;n.lods.forEach(((e,i)=>{e.resolution=t*2**i,e.scale=96*e.resolution/.0254}))}}}async _fetchPixels(e,t,i,n={}){let r=(0,k.OM)(e);if(r>=2)return{extent:e,pixelBlock:null};const s=this._getSourceDataInfo(e,t,i,n),{pyramidLevel:o,srcResolution:a,srcExtent:l,srcWidth:c,srcHeight:u,ul:h}=s;if(0===c||0===u)return{extent:e,srcExtent:l,pixelBlock:null};const{rasterInfo:m}=this,d=m.transform,p="gcs-shift"===d?.type,y=null!=(0,k.FT)(e.spatialReference);!p&&y||(r=(0,k.OM)(s.srcExtent,p));const x=await this._fetchRawTiles(o,h,{width:c,height:u,wrapCount:r},n);if(!x)return{extent:e,srcExtent:l,pixelBlock:null};const g=m.storageInfo,I=o>0?g.pyramidBlockWidth:g.blockWidth,R=o>0?g.pyramidBlockHeight:g.blockHeight;let{x:b,y:w}=m.pixelSize;if(o>0){const{pyramidResolutions:e,pyramidScalingFactor:t}=g;if(null!=e&&e[o-1])({x:b,y:w}=e[o-1]);else{const e=t**o;b*=e,w*=e}}const _=m.spatialReference,S=new f.A({x:b,y:w,spatialReference:_}),v=I===c&&R===u&&h.x%I==0&&h.y%R==0,T=new f.A({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference}),P=!e.spatialReference.equals(_),A=_.isGeographic?1e-9:1e-4,{datumTransformation:D}=n;if(!P&&v&&1===x.pixelBlocks.length&&I===t&&R===i&&function(e,t,i){return Math.abs(e.x-t.x)<i&&Math.abs(e.y-t.y)<i}(a,T,A))return{extent:e,srcExtent:l,srcTilePixelSize:S,pixelBlock:x.pixelBlocks[0]};const C=y&&null!=(0,k.FT)(l.spatialReference)&&this._hasNoneOrGCSShiftTransform,z=n.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");z&&!this.rasterJobHandler&&await(0,k.Hh)();const B=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:x.extent,pixelSize:T.toJSON(),datumTransformation:D,rasterTransform:d,hasWrapAround:r>0||C,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:z},n):(0,k.l0)({projectedExtent:e,srcBufferExtent:x.extent,pixelSize:T,datumTransformation:D,rasterTransform:d,hasWrapAround:r>0||C,isAdaptive:!1,includeGCSGrid:z});let H;const J=!n.requestRawData,N={rows:B.spacing[0],cols:B.spacing[1]},O=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(o,x.extent.xmin):void 0,{pixelBlocks:E,mosaicSize:W,isPartiallyFilled:L}=x;let Z=null;if(this.rasterJobHandler){const e=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:E,srcMosaicSize:W,destDimension:J?{width:t,height:i}:null,coefs:J?B.coefficients:null,sampleSpacing:J?N:null,projectDirections:z,gcsGrid:z?B.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:n.interpolation,alignmentInfo:O,blockWidths:null},n);({pixelBlock:H,localNorthDirections:Z}=e)}else{const e=(0,M.z7)(E,W,{alignmentInfo:O});H=J?(0,M.$i)(e,{width:t,height:i},B.coefficients,N,n.interpolation):e,z&&B.gcsGrid&&(Z=(0,M.QF)({width:t,height:i},B.gcsGrid),H=(0,F.Y2)(H,this.rasterInfo.dataType,Z))}return n.requestRawData||z?{extent:e,srcExtent:l,srcTilePixelSize:S,pixelBlock:H,transformGrid:B,localNorthDirections:Z,isPartiallyFilled:L}:{extent:e,srcExtent:l,srcTilePixelSize:S,pixelBlock:H}}async _fetchRawTiles(e,t,i,n){const{origin:r,blockBoundary:s}=this.rasterInfo.storageInfo,{blockWidth:o,blockHeight:a}=this.getBlockWidthHeight(e);let{x:l,y:c}=t,{width:u,height:h,wrapCount:m}=i;const f=this._getRasterTileAlignmentInfo(e,0);n.buffer&&(l-=n.buffer.cols,c-=n.buffer.rows,u+=2*n.buffer.cols,h+=2*n.buffer.rows);let p=0,y=0,x=0;m&&null!=f&&(({worldColumnCountFromOrigin:y,originColumnOffset:x,rightPadding:p}=f),y*f.blockWidth-p>=l+u&&(p=0));const g=Math.floor(l/o),I=Math.floor(c/a),R=Math.floor((l+u+p-1)/o),b=Math.floor((c+h+p-1)/a),w=s[e];if(!w)return null;const{minRow:_,minCol:S,maxCol:v,maxRow:T}=w;if(0===m&&(b<_||R<S||I>T||g>v))return null;const M=new Array;let k=!1;const F=null==this.ioConfig.allowPartialFill?n.allowPartialFill:this.ioConfig.allowPartialFill;for(let d=I;d<=b;d++)for(let t=g;t<=R;t++){let i=t;if(!n.disableWrapAround&&m&&null!=f&&y<=t&&(i=t-y-x),d>=_&&i>=S&&T>=d&&v>=i){const t=this._tileFetchQueue.push({pyramidLevel:e,row:d,col:i,options:n},{signal:n.signal});F?M.push(new Promise((e=>{t.then((t=>e(t))).catch((()=>{k=!0,e(null)}))}))):M.push(t)}else M.push(Promise.resolve(null))}if(0===M.length)return null;const P=await Promise.all(M),A={height:(b-I+1)*a,width:(R-g+1)*o},{spatialReference:D}=this.rasterInfo,C=this.getPyramidPixelSize(e),{x:z,y:B}=C;return{extent:new d.A({xmin:r.x+g*o*z,xmax:r.x+(R+1)*o*z,ymin:r.y-(b+1)*a*B,ymax:r.y-I*a*B,spatialReference:D}),pixelBlocks:P,mosaicSize:A,isPartiallyFilled:k}}_fetchRawTile(e,t,i,n){const{storageInfo:r}=this.rasterInfo,s=null!=r.transposeInfo&&!!n.transposedVariableName;if(!s){const n=r.blockBoundary[e];if(!n)return Promise.resolve(null);const{minRow:s,minCol:o,maxCol:a,maxRow:l}=n;if(t<s||i<o||t>l||i>a)return Promise.resolve(null)}const o=s?n.transposeVariableName:n.sliceId,a=this.rasterInfo.storageInfo.isBsqTile?n.bandIds:null,c=(0,S.ph)(this.rasterId,o,a),u=`${e}/${t}/${i}`;let h=(0,S.gd)(c,n.registryId,u);if(null==h){const r=new AbortController;h=this.fetchRawTile(e,t,i,{...n,signal:r.signal}),(0,S.no)(c,n.registryId,u,h,r),h.catch((()=>(0,S.zo)(c,n.registryId,u)))}return n.signal&&(0,l.u7)(n,(()=>{(0,S.jX)(c,n.registryId,u)})),h}_computeMagDirValues(e){const{bandCount:t,dataType:i}=this.rasterInfo;if((2!==t||"vector-magdir"!==i)&&"vector-uv"!==i||2!==e?.length||!e[0]?.length)return null;const n=e[0].length;if("vector-magdir"===i){const t=e[1].map((e=>(e+360)%360));return[e[0],t]}const[r,s]=e,o=[],a=[];for(let l=0;l<n;l++){const[e,t]=(0,F.Lu)([r[l],s[l]]);o.push(e),a.push(t)}return[o,a]}_getRasterTileAlignmentInfo(e,t){return null==this._rasterTileAlignmentInfo&&(this._rasterTileAlignmentInfo=(0,k.DO)(this.rasterInfo)),null==this._rasterTileAlignmentInfo.pyramidsInfo?null:{startX:t,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[e]}}_getSourceDataInfo(e,t,i,n={}){const r={datumTransformation:n.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};n.srcResolution&&(r.srcResolution=n.srcResolution,this._updateSourceDataInfo(e,r));const s=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:o,srcHeight:a,pyramidLevel:l}=r,c=o/t,u=a/i,h=l<s&&c*u>=16,m=l===s&&this._requireTooManySrcTiles(o,a,t,i);if(h||m||0===o||0===a){const o=new f.A({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference});let a=(0,k.Wo)(o,this.rasterInfo.spatialReference,e,r.datumTransformation);const m=!a||n.srcResolution&&a.x+a.y<n.srcResolution.x+n.srcResolution.y;if(h&&n.srcResolution&&m){const e=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(s-l+3>=e){const t=2**e;a={x:n.srcResolution.x*t,y:n.srcResolution.y*t}}}a&&(r.srcResolution=a,this._updateSourceDataInfo(e,r))}return this._requireTooManySrcTiles(r.srcWidth,r.srcHeight,t,i)&&(r.srcWidth=0,r.srcHeight=0),r}_requireTooManySrcTiles(e,t,i,n){const{tileInfo:r}=this.rasterInfo.storageInfo,s=e/i,o=t/n;return Math.ceil(e/r.size[0])*Math.ceil(t/r.size[1])>=256*Math.max(1,(i+n)/1024)||s>8||o>8}_updateSourceDataInfo(e,t){t.srcWidth=0,t.srcHeight=0;const{rasterInfo:i}=this,n=i.spatialReference,{srcResolution:r,datumTransformation:s}=t,{pyramidLevel:o,pyramidResolution:a,excessiveReading:l}=(0,k.t$)(r,i,this.ioConfig.sampling);if(l)return;let c=t.srcExtent||(0,k._l)(e,n,s);if(null==c)return;const u=i.transform;u&&(c=u.inverseTransform(c)),t.srcExtent=c;const{x:h,y:m}=i.storageInfo.origin,d=Math.floor((c.xmin-h)/a.x+.1),f=Math.floor((m-c.ymax)/a.y+.1),p=Math.floor((c.xmax-h)/a.x-.1),y=Math.floor((m-c.ymin)/a.y-.1),x=c.width<.1*a.x?0:p-d+1,g=c.height<.1*a.y?0:y-f+1;t.pyramidLevel=o,t.pyramidResolution=a,t.srcWidth=x,t.srcHeight=g,t.ul={x:d,y:f}}_getRequestOptionsWithSliceId(e){return null!=this.rasterInfo.multidimensionalInfo&&null==e.sliceId&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}_processIdentifyResult(e,t){const{srcLocation:i,position:n,pyramidLevel:r,useTransposedTile:s}=t,o=e.pixels[0].length/e.width/e.height;if(e.mask&&!e.mask[n])return{location:i,value:null};const{multidimensionalInfo:a}=this.rasterInfo;if(null==a||!s){const t=e.pixels.map((e=>e[n])),s={location:i,value:t,pyramidLevel:r},o=this._computeMagDirValues(t.map((e=>[e])));return o?.length&&(s.magdirValue=o.map((e=>e[0]))),s}let l=e.pixels.map((e=>e.slice(n*o,n*o+o))),c=this._computeMagDirValues(l);const{requestSomeSlices:u,identifyOptions:h}=t;let m=(0,_.QW)(a,h.transposedVariableName);if(u){const e=(0,_.xx)(m,h.multidimensionalDefinition,h.timeExtent);l=l.map((t=>e.map((e=>t[e])))),c=c?.map((t=>e.map((e=>t[e])))),m=e.map((e=>m[e]))}const d=e.noDataValues||this.rasterInfo.noDataValue,f={pixels:l,pixelType:e.pixelType};let p;return null!=d&&((0,v.Sp)(f,d),p=f.mask),{location:i,value:null,dataSeries:m.map(((e,t)=>{const i={value:0===p?.[t]?null:l.map((e=>e[t])),multidimensionalDefinition:e.multidimensionalDefinition.map((e=>new g.A({...e,isSlice:!0})))};return c?.length&&(i.magdirValue=[c[0][t],c[1][t]]),i})),pyramidLevel:r}}};(0,n._)([(0,u.MZ)()],A.prototype,"_rasterTileAlignmentInfo",void 0),(0,n._)([(0,u.MZ)()],A.prototype,"_tileFetchQueue",void 0),(0,n._)([(0,u.MZ)({readOnly:!0})],A.prototype,"_isGlobalWrappableSource",null),(0,n._)([(0,u.MZ)({readOnly:!0})],A.prototype,"_hasNoneOrGCSShiftTransform",null),(0,n._)([(0,u.MZ)()],A.prototype,"_openPromise",void 0),(0,n._)([(0,u.MZ)()],A.prototype,"rasterJobHandler",null),(0,n._)([(0,u.MZ)({readOnly:!0})],A.prototype,"rasterId",null),(0,n._)([(0,u.MZ)(x.OZ)],A.prototype,"url",null),(0,n._)([(0,u.MZ)({type:String,json:{write:!0}})],A.prototype,"datasetName",void 0),(0,n._)([(0,u.MZ)({type:String,json:{write:!0}})],A.prototype,"datasetFormat",void 0),(0,n._)([(0,u.MZ)()],A.prototype,"hasUniqueSourceStorageInfo",void 0),(0,n._)([(0,u.MZ)()],A.prototype,"rasterInfo",void 0),(0,n._)([(0,u.MZ)()],A.prototype,"ioConfig",void 0),(0,n._)([(0,u.MZ)()],A.prototype,"sourceJSON",void 0),A=(0,n._)([(0,m.$)("esri.layers.support.rasterDatasets.BaseRaster")],A)},96822:(e,t,i)=>{i.d(t,{A:()=>d});var n=i(66866),r=i(98849),s=i(21564),o=(i(39831),i(539),i(9272),i(63863)),a=i(62802),l=i(55799),c=i(5572),u=i(20498),h=i(15995),m=i(57822);let d=class extends l.A{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(e,t,i,n={}){const{rasters:r,rasterIds:s}=this.primaryRasters;let o=!1;const{interpolation:a}=n,l=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!n.requestRawData&&l&&(o=1===r.length&&!n.skipRasterFunction,n={...n,interpolation:"bilinear",requestRawData:o});const h=r.map((r=>r.fetchPixels(e,t,i,n))),m=await Promise.all(h),d=m.map((e=>e.pixelBlock)),f=o||n.requestRawData?m.map((e=>e.srcTilePixelSize)):null;if(n.skipRasterFunction||d.every((e=>null==e)))return m[0];const p=m.find((e=>null!=e.pixelBlock))?.extent??e;let y=this.rasterJobHandler?await this.rasterJobHandler.process({extent:p,primaryPixelBlocks:d,primaryPixelSizes:f,primaryRasterIds:s}):this.rasterFunction.process({extent:p,primaryPixelBlocks:d,primaryPixelSizes:f,primaryRasterIds:s});const{transformGrid:x}=m[0];if(!o||null==y||null==x){const e=n.noClip?null:this.getClippingGeometry(p.spatialReference);return n.noClip||n.requestRawData||null==y||!e||(y=await(0,c.$Q)(y,p,e)),{...m[0],pixelBlock:y}}const g={rows:x.spacing[0],cols:x.spacing[1]};let I;I=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[y],srcMosaicSize:{width:y.width,height:y.height},destDimension:{width:t,height:i},coefs:x.coefficients,sampleSpacing:g,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:a,alignmentInfo:void 0,blockWidths:null},n)).pixelBlock:(0,u.$i)(y,{width:t,height:i},x.coefficients,g,a);const R=n.noClip?null:this.getClippingGeometry(e.spatialReference);return n.noClip||n.requestRawData||null==I||null==R||(I=await(0,c.$Q)(I,e,R)),{extent:e,srcExtent:m[0].srcExtent,pixelBlock:I}}getClippingGeometry(e){const t=this._clippingGeometry.get("0");if(!e||!t)return t;const i=function(e){return String(e.wkid??e.wkt??e.wkt2)}(e);let n=this._clippingGeometry.get(i);return null!=n||(n=e.equals(t.spatialReference)?t:(0,h.uk)(t,e),this._clippingGeometry.set(i,n)),n}async _open(e){const{rasterFunction:t}=this;t.isRoot=!0,this.primaryRasters?.rasters?.length?t.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=t.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach((e=>e.rasterJobHandler=this.rasterJobHandler)));const{rasters:i,rasterIds:n}=this.primaryRasters,s=i.map((t=>t.rasterInfo?void 0:t.open(e)));await Promise.all(s);const o=i.map((({rasterInfo:e})=>e)),a=t.bind({rasterInfos:o,rasterIds:n});if(t.rawSourceRasterInfos=o,!a.success||0===o.length)throw new r.A("raster-function:open",`cannot bind the function: ${a.error??""}`);const l="Table"===t.functionName?t:t.functionArguments?.raster;"Table"===l?.functionName&&(t.rasterInfo.attributeTable=m.A.fromJSON(l.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const c=o[0];this.hasUniqueSourceStorageInfo=1===o.length||o.slice(1).every((e=>function(e,t){const{storageInfo:i,pixelSize:n,spatialReference:r,extent:s}=e,{storageInfo:o,pixelSize:a,spatialReference:l,extent:c}=t;return n.x===a.x&&n.y===a.y&&r.equals(l)&&s.equals(c)&&i.blockHeight===o.blockHeight&&i.blockWidth===o.blockWidth&&i.maximumPyramidLevel===o.maximumPyramidLevel}(e,c))),this.set("sourceJSON",i[0].sourceJSON),this.set("rasterInfo",t.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const e=this.rasterFunction.getClippingGeometries()[0];let t=e?.clippingGeometry;if(t&&"inside"===e.clippingType){const{extent:e}=this.rasterInfo,n=await Promise.all([i.e(72076),i.e(89468)]).then(i.bind(i,89468)),r=await Promise.all([i.e(72076),i.e(50159)]).then(i.bind(i,50159));let s=n.execute(a.A.fromExtent(e),2*(e.width+e.height)/40);s=(0,h.uk)(s,t.spatialReference),t=r.execute(s,t)}this._clippingGeometry.clear(),t&&this._clippingGeometry.set("0",t)}};(0,n._)([(0,s.MZ)({type:String,json:{write:!0}})],d.prototype,"datasetFormat",void 0),(0,n._)([(0,s.MZ)()],d.prototype,"tileType",void 0),(0,n._)([(0,s.MZ)()],d.prototype,"rasterFunction",void 0),(0,n._)([(0,s.MZ)()],d.prototype,"primaryRasters",void 0),d=(0,n._)([(0,o.$)("esri.layers.support.rasterDatasets.FunctionRaster")],d)},53136:(e,t,i)=>{function n(e,t){if(!e||!t)return[];let i=t;t.includes("/")?(i=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const r=[];if(t){const s=n(e,i);for(let e=0;e<s.length;e++)n(s[e],t).forEach((e=>r.push(e)));return r}const s=e.getElementsByTagNameNS("*",i);if(!s||0===s.length)return[];for(let n=0;n<s.length;n++)r.push(s[n]||s.item(n));return r}function r(e,t){if(!e||!t)return null;let i=t;t.includes("/")?(i=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const s=n(e,i);return s.length>0?t?r(s[0],t):s[0]:null}function s(e,t=null){const i=t?r(e,t):e;let n;return i?(n=i.textContent||i.nodeValue,n?n.trim():null):null}function o(e,t){const i=n(e,t),r=[];let s;for(let n=0;n<i.length;n++)s=i[n].textContent||i[n].nodeValue,s&&(s=s.trim(),""!==s&&r.push(s));return r}function a(e,t=null){const i=s(e,t);return i?.split(" ").map((e=>Number(e)))??[]}function l(e,t){return o(e,t).map((e=>Number(e)))}function c(e,t){const i=s(e,t);return Number(i)}function u(e,t){const i=e?.nodeName?.toLowerCase(),n=t.toLowerCase();return i.slice(i.lastIndexOf(":")+1)===n}function h(e){return e.nodeName.slice(e.nodeName.lastIndexOf(":")+1)}i.d(t,{Dy:()=>o,IC:()=>n,Ui:()=>l,V6:()=>r,g7:()=>u,mX:()=>s,pN:()=>a,v7:()=>c,vv:()=>h})}}]);